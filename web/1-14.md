# 📚 FastAPI + SQLAlchemy 프로젝트 가이드

> 이 문서는 FastAPI와 SQLAlchemy를 활용한 CRUD API 프로젝트의 전체 구조와 코드를 상세히 설명합니다.

---

## 🗂️ 파일 연결 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                         orm.py                                  │
│                    (Base 클래스 정의)                            │
│              모든 ORM 모델의 부모 클래스                          │
└───────────────────────────┬─────────────────────────────────────┘
                            │ from orm import Base
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                        models.py                                │
│                    (Item 모델 정의)                              │
│              DB 테이블과 매핑되는 ORM 객체                        │
└───────────────────────────┬─────────────────────────────────────┘
                            │ from models import Item
                            ├─────────────────────────────────────┐
                            ▼                                     ▼
┌─────────────────────────────────────┐   ┌───────────────────────────────────┐
│         typing_prompt.py            │   │            crud.py                │
│       (테이블 생성 스크립트)          │   │    (FastAPI CRUD API 서버)         │
│  models + connection 조합 → DB 생성  │   │   🔗 DB 연결된 완전한 CRUD!        │
│               ▲                     │   │               ▲                   │
└───────────────┼─────────────────────┘   └───────────────┼───────────────────┘
                │                                         │
                │ from connection import engine           │ from connection import SessionFactory
                │                                         │
┌───────────────┴─────────────────────────────────────────┴───────────────────┐
│                            connection.py                                    │
│                         (DB 연결 설정)                                       │
│                   engine과 SessionFactory 제공                               │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                         과제.py                                 │
│                   (PUT 메서드 학습용)                            │
│              독립적인 API (DB 미연결, 메모리 사용)                 │
└─────────────────────────────────────────────────────────────────┘
```

## 📄 1. orm.py

### 📌 파일 설명
> SQLAlchemy ORM의 **기반 클래스(Base)**를 정의합니다.  
> 모든 DB 모델은 이 Base 클래스를 상속받아야 합니다.

### 📝 전체 코드

```python
### Base 클래스 정의 ###
 
from sqlalchemy.orm import DeclarativeBase
#───────────────────────────────────────────────────────────────────
# sqlalchemy.orm: SQLAlchemy의 ORM(Object-Relational Mapping) 모듈
# DeclarativeBase: SQLAlchemy 2.0 스타일의 기반 클래스
#   - 이 클래스를 상속받으면 Python 클래스가 DB 테이블과 매핑됨
#───────────────────────────────────────────────────────────────────

class Base(DeclarativeBase):
    pass
#───────────────────────────────────────────────────────────────────
# Base 클래스 정의
#   - DeclarativeBase를 상속받아 커스텀 Base 생성
#   - pass: 아무 내용 없이 상속만 받음
#   - 이 Base를 상속받는 모든 클래스는 자동으로 DB 테이블이 됨
#
# 왜 굳이 한번 더 감싸나?
#   - 프로젝트 전체에서 공통으로 사용할 Base를 한 곳에서 관리
#   - 나중에 공통 컬럼(created_at 등)을 추가하기 쉬움
#───────────────────────────────────────────────────────────────────
```

---

## 📄 2. models.py

### 📌 파일 설명
> **Item** 테이블을 정의하는 ORM 모델입니다.  
> Python 클래스로 DB 테이블 구조를 선언합니다.

### 📝 전체 코드

```python
### Item 모델 정의 ###

from orm import Base
#───────────────────────────────────────────────────────────────────
# orm.py에서 정의한 Base 클래스를 가져옴
# 이 Base를 상속받아야 DB 테이블로 인식됨
#───────────────────────────────────────────────────────────────────

from sqlalchemy import Integer, String
#───────────────────────────────────────────────────────────────────
# Integer: 정수형 컬럼 타입 (id, price 등)
# String: 문자열 컬럼 타입 (name 등)
#   - String(128): 최대 128자까지 저장 가능
#───────────────────────────────────────────────────────────────────

from sqlalchemy.orm import Mapped, mapped_column
#───────────────────────────────────────────────────────────────────
# Mapped[타입]: Python 타입 힌트와 결합된 컬럼 선언 방식
#   - Mapped[int]: 이 컬럼은 정수형이라는 것을 명시
#   - Mapped[str]: 이 컬럼은 문자열이라는 것을 명시
#
# mapped_column(): 컬럼의 상세 옵션을 설정
#   - primary_key=True: 기본키로 지정
#   - String(128): 최대 길이 지정
#───────────────────────────────────────────────────────────────────

# Item 데이터를 저장할 DB 테이블 & ORM 객체
class Item(Base):
#───────────────────────────────────────────────────────────────────
# Item 클래스 정의
#   - Base를 상속받아 DB 테이블로 등록
#   - 이 클래스의 인스턴스 = DB의 한 행(row)
#───────────────────────────────────────────────────────────────────

    __tablename__ = "items"
#───────────────────────────────────────────────────────────────────
# __tablename__: 실제 DB에 생성될 테이블 이름
#   - "items" → DB에 items라는 테이블이 생성됨
#   - 클래스명(Item)과 테이블명(items)은 다를 수 있음
#───────────────────────────────────────────────────────────────────

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
#───────────────────────────────────────────────────────────────────
# id 컬럼 정의
#   - Mapped[int]: Python에서 int 타입으로 사용
#   - Integer: DB에서 INTEGER 타입
#   - primary_key=True: 기본키(PK)로 지정
#     → 각 행을 고유하게 식별하는 키
#     → 자동 증가(auto increment) 적용됨
#───────────────────────────────────────────────────────────────────

    name: Mapped[str] = mapped_column(String(128))
#───────────────────────────────────────────────────────────────────
# name 컬럼 정의
#   - Mapped[str]: Python에서 str 타입으로 사용
#   - String(128): DB에서 VARCHAR(128) 타입
#     → 최대 128자까지 저장 가능
#───────────────────────────────────────────────────────────────────

    price: Mapped[int] = mapped_column(Integer)
#───────────────────────────────────────────────────────────────────
# price 컬럼 정의
#   - Mapped[int]: Python에서 int 타입으로 사용
#   - Integer: DB에서 INTEGER 타입
#───────────────────────────────────────────────────────────────────
```

### 📊 생성되는 테이블 구조

| 컬럼명 | 타입 | 제약조건 |
|--------|------|----------|
| id | INTEGER | PRIMARY KEY, AUTO INCREMENT |
| name | VARCHAR(128) | - |
| price | INTEGER | - |

---

## 📄 3. connection.py

### 📌 파일 설명
> **데이터베이스 연결 설정**을 담당합니다.  
> engine(연결)과 SessionFactory(세션 생성기)를 제공합니다.

### 📝 전체 코드

```python
from sqlalchemy import create_engine
#───────────────────────────────────────────────────────────────────
# create_engine: DB 연결을 생성하는 함수
#   - DB와의 실제 연결(connection)을 관리
#   - 연결 풀(connection pool)도 자동으로 관리
#───────────────────────────────────────────────────────────────────

from sqlalchemy.orm import sessionmaker
#───────────────────────────────────────────────────────────────────
# sessionmaker: 세션 팩토리(Session Factory)를 만드는 함수
#   - 세션(Session): DB 작업의 단위
#   - 팩토리 패턴: 세션 객체를 찍어내는 공장
#───────────────────────────────────────────────────────────────────

# 데이터베이스 접속 정보
DATABASE_URL = "sqlite:///./test.db"
#───────────────────────────────────────────────────────────────────
# DATABASE_URL: 접속할 DB의 주소
#
# "sqlite:///./test.db" 분석:
#   - sqlite://  → SQLite 데이터베이스 사용
#   - /./        → 현재 디렉토리 (상대 경로)
#   - test.db    → 파일 이름
#
# 결과: 현재 폴더에 test.db 파일이 생성됨
#
# 다른 DB 예시:
#   - PostgreSQL: "postgresql://user:password@localhost/dbname"
#   - MySQL: "mysql://user:password@localhost/dbname"
#───────────────────────────────────────────────────────────────────

# 엔진(Engine) = SQLAlchemy 사용시 DB와 연결관리
engine = create_engine(DATABASE_URL)
#───────────────────────────────────────────────────────────────────
# engine 생성
#   - DATABASE_URL을 사용해 DB 연결 엔진 생성
#   - 이 engine을 통해 DB에 SQL 실행 가능
#   - 아직 실제 연결은 안 됨 (lazy connection)
#───────────────────────────────────────────────────────────────────

# 세션(Session) = DB 작업관리
# 세션을 만들 수 있는 세션 팩토리
SessionFactory = sessionmaker(
    bind=engine,
#───────────────────────────────────────────────────────────────────
# bind=engine
#   - 이 세션 팩토리가 사용할 엔진 지정
#   - 세션이 생성되면 이 엔진을 통해 DB와 통신
#───────────────────────────────────────────────────────────────────

    autocommit=False,
#───────────────────────────────────────────────────────────────────
# autocommit=False (기본값)
#   - False: 명시적으로 commit()을 호출해야 저장됨
#   - True: 각 SQL 실행 후 자동 커밋 (위험!)
#   
# 왜 False?
#   - 여러 작업을 하나의 트랜잭션으로 묶을 수 있음
#   - 문제 발생시 rollback()으로 되돌리기 가능
#───────────────────────────────────────────────────────────────────

    autoflush=False,
#───────────────────────────────────────────────────────────────────
# autoflush=False
#   - False: 명시적으로 flush()를 호출해야 DB에 반영
#   - True: 쿼리 실행 전 자동으로 flush
#
# flush vs commit:
#   - flush: 변경사항을 DB에 전송 (아직 확정 X)
#   - commit: flush + 트랜잭션 확정
#───────────────────────────────────────────────────────────────────

    expire_on_commit=False,  # 데이터를 다룰 때 사용되는 옵션(다 꺼놓는게 안전)
#───────────────────────────────────────────────────────────────────
# expire_on_commit=False
#   - False: commit 후에도 객체 속성 접근 가능
#   - True: commit 후 객체 접근시 DB에서 다시 조회 (기본값)
#
# 왜 False?
#   - 성능 향상: 불필요한 DB 조회 방지
#   - commit 후에도 객체 데이터를 바로 사용 가능
#───────────────────────────────────────────────────────────────────
)
```

### 🔧 세션 옵션 요약

| 옵션 | 값 | 의미 |
|------|-----|------|
| `autocommit` | False | 수동 커밋 (안전) |
| `autoflush` | False | 수동 플러시 (제어 가능) |
| `expire_on_commit` | False | 커밋 후 재조회 안 함 (성능) |

---

## 📄 4. typing_prompt.py

### 📌 파일 설명
> models.py와 connection.py를 조합해 **실제 DB 테이블을 생성**하는 스크립트입니다.  
> `python -i typing_prompt.py` 명령으로 실행합니다.

### 📝 전체 코드

```python
from models import Item
#───────────────────────────────────────────────────────────────────
# models.py에서 Item 클래스를 가져옴
# Item을 import하면 자동으로 Base의 metadata에 등록됨
#───────────────────────────────────────────────────────────────────

from orm import Base
#───────────────────────────────────────────────────────────────────
# orm.py에서 Base 클래스를 가져옴
# Base.metadata: 등록된 모든 테이블 정보를 담고 있음
#───────────────────────────────────────────────────────────────────

from connection import engine
#───────────────────────────────────────────────────────────────────
# connection.py에서 engine을 가져옴
# 이 engine을 통해 실제 DB에 테이블 생성
#───────────────────────────────────────────────────────────────────

# Item 클래스 확인
print(Item)  # <class '__main__.Item'>
#───────────────────────────────────────────────────────────────────
# Item 클래스가 제대로 import 되었는지 확인
# 출력: <class 'models.Item'>
#───────────────────────────────────────────────────────────────────

# Base 클래스 확인
print(Base)  # <class 'orm.Base'>
#───────────────────────────────────────────────────────────────────
# Base 클래스 확인
# 출력: <class 'orm.Base'>
#───────────────────────────────────────────────────────────────────

# engine 확인
print(engine)  # Engine(sqlite:///./test.db)
#───────────────────────────────────────────────────────────────────
# engine 객체 확인
# 출력: Engine(sqlite:///./test.db)
#───────────────────────────────────────────────────────────────────

# DB 테이블 생성
Base.metadata.create_all(bind=engine)
#───────────────────────────────────────────────────────────────────
# 핵심 코드! 테이블 생성
#
# Base.metadata:
#   - Base를 상속받은 모든 모델의 테이블 정보
#   - Item 클래스 → items 테이블 정보 포함
#
# create_all(bind=engine):
#   - metadata에 등록된 모든 테이블을 DB에 생성
#   - bind=engine: 어느 DB에 생성할지 지정
#   - 이미 테이블이 있으면 무시 (안전)
#
# 실행 결과:
#   - 현재 디렉토리에 test.db 파일 생성
#   - test.db 안에 items 테이블 생성
#───────────────────────────────────────────────────────────────────
```

### 🚀 실행 방법

```bash
# 1. 디렉토리 이동
cd /Users/admin/Desktop/FASTAPI/1.14

# 2. 대화형 모드로 실행
python -i typing_prompt.py

# 3. 결과 확인
# → test.db 파일이 생성됨
# → items 테이블이 생성됨
```

---

## 📄 5. crud.py

### 📌 파일 설명
> **완전한 CRUD API**를 구현한 FastAPI 앱입니다.  
> 🔗 **orm.py, models.py, connection.py와 연결되어 실제 DB 사용!**  
> - **C**reate: POST `/items` - 상품 등록
> - **R**ead: GET `/items`, GET `/items/{id}` - 상품 조회
> - **U**pdate: PATCH `/items/{id}` - 부분 수정, PUT `/items/{id}` - 전체 교체
> - **D**elete: DELETE `/items/{id}` - 상품 삭제

### 📝 전체 코드

```python
from fastapi import FastAPI, Path, HTTPException, status
#───────────────────────────────────────────────────────────────────
# FastAPI: 웹 API 프레임워크 메인 클래스
# Path: 경로 파라미터 검증용 (여기선 import만 해둠)
# HTTPException: HTTP 에러 응답용 예외 클래스
# status: HTTP 상태 코드 상수 (HTTP_200_OK, HTTP_404_NOT_FOUND 등)
#───────────────────────────────────────────────────────────────────

from pydantic import BaseModel
#───────────────────────────────────────────────────────────────────
# BaseModel: 요청/응답 데이터 검증용 Pydantic 클래스
#───────────────────────────────────────────────────────────────────

from sqlalchemy import select
#───────────────────────────────────────────────────────────────────
# select: SQL SELECT 쿼리를 만드는 함수
#   - select(Item) = SELECT * FROM items
#   - select(Item).where(...) = SELECT * FROM items WHERE ...
#───────────────────────────────────────────────────────────────────

from connection import SessionFactory
#───────────────────────────────────────────────────────────────────
# 🔗 connection.py와 연결!
# SessionFactory: DB 세션을 만드는 팩토리
#   - SessionFactory() 호출하면 새 세션 생성
#   - 세션으로 DB 작업 수행
#───────────────────────────────────────────────────────────────────

from models import Item
#───────────────────────────────────────────────────────────────────
# 🔗 models.py와 연결!
# Item: DB의 items 테이블과 매핑된 ORM 모델
#   - Item 객체 = DB의 한 행(row)
#───────────────────────────────────────────────────────────────────

app = FastAPI()
#───────────────────────────────────────────────────────────────────
# FastAPI 앱 인스턴스 생성
#───────────────────────────────────────────────────────────────────


# ═══════════════════════════════════════════════════════════════════
# 📋 요청/응답 스키마 정의
# ═══════════════════════════════════════════════════════════════════

class ItemCreateRequest(BaseModel):
    name: str
    price: int
#───────────────────────────────────────────────────────────────────
# 상품 생성(Create) 요청 스키마
#   - name: 상품명 (필수)
#   - price: 가격 (필수)
#   - id는 DB에서 자동 생성되므로 없음!
#───────────────────────────────────────────────────────────────────


class ItemResponse(BaseModel):
    id: int
    name: str
    price: int
#───────────────────────────────────────────────────────────────────
# 상품 응답 스키마
#   - id: DB에서 생성된 기본키
#   - name: 상품명
#   - price: 가격
#───────────────────────────────────────────────────────────────────


class ItemUpdateRequest(BaseModel):
    name: str | None = None
    price: int | None = None
#───────────────────────────────────────────────────────────────────
# 상품 수정(PATCH) 요청 스키마
#   - str | None = None: 선택적 필드 (안 보내도 OK)
#   - PATCH는 부분 수정이니까 모든 필드가 Optional!
#───────────────────────────────────────────────────────────────────


class ItemReplaceRequest(BaseModel):
    name: str
    price: int
#───────────────────────────────────────────────────────────────────
# 상품 교체(PUT) 요청 스키마
#   - PUT은 전체 교체니까 모든 필드 필수!
#   - PATCH와의 차이: None 허용 안 함
#───────────────────────────────────────────────────────────────────


# ═══════════════════════════════════════════════════════════════════
# 🟢 C: Create - 상품 등록 API
# ═══════════════════════════════════════════════════════════════════

@app.post("/items", status_code=status.HTTP_201_CREATED)
def create_item_api(body: ItemCreateRequest) -> ItemResponse:
#───────────────────────────────────────────────────────────────────
# @app.post: POST 메서드 (생성)
# status_code=201: 리소스 생성 성공 (Created)
#   - 200 OK와 다름! 201은 "새로 만들었다"는 의미
#───────────────────────────────────────────────────────────────────

    with SessionFactory() as session:
#───────────────────────────────────────────────────────────────────
# with 문으로 세션 사용
#
# Q: with가 뭐야?
# A: → 컨텍스트 매니저 (Context Manager)
#    → 자동으로 시작/종료 처리해줌
#    → with 블록 끝나면 세션 자동 정리 (close)
#
# Q: 왜 with를 써?
# A: → 세션은 다 쓰면 반드시 닫아야 함
#    → with 없으면: session = SessionFactory() ... session.close()
#    → with 쓰면: 자동으로 close 호출됨 (깜빡해도 OK)
#───────────────────────────────────────────────────────────────────

        new_item = Item(name=body.name, price=body.price)
#───────────────────────────────────────────────────────────────────
# Item 객체 생성
#   - models.py의 Item 클래스 인스턴스
#   - 아직 DB에 저장 안 됨! (메모리에만 존재)
#   - id는 자동 생성되니까 안 넣어도 됨
#───────────────────────────────────────────────────────────────────

        session.add(new_item)
#───────────────────────────────────────────────────────────────────
# 세션에 객체 추가
#
# Q: add가 뭐야?
# A: → "이 객체를 DB에 저장할 거야" 라고 세션에 알려줌
#    → 아직 DB에 반영 안 됨! (대기 상태)
#
# Q: 왜 바로 저장 안 해?
# A: → 여러 작업을 묶어서 한번에 처리하려고 (트랜잭션)
#    → add → add → add → commit (한번에 저장)
#───────────────────────────────────────────────────────────────────

        session.commit()  # DB에 반영
#───────────────────────────────────────────────────────────────────
# 커밋: 변경사항을 DB에 확정
#
# Q: commit이 뭐야?
# A: → "지금까지 한 작업들 진짜로 저장해!" 명령
#    → add한 객체가 실제 DB에 INSERT됨
#    → 이때 id가 자동 생성됨 (auto increment)
#
# Q: commit 안 하면?
# A: → DB에 아무것도 안 저장됨!
#    → 세션 끝나면 모든 변경사항 사라짐
#───────────────────────────────────────────────────────────────────

        return new_item
#───────────────────────────────────────────────────────────────────
# 생성된 아이템 반환
#   - commit 후에 new_item.id가 할당됨
#   - FastAPI가 ItemResponse 형태로 검증 후 JSON 반환
#───────────────────────────────────────────────────────────────────


# ═══════════════════════════════════════════════════════════════════
# 🔵 R: Read - 전체 상품 조회 API
# ═══════════════════════════════════════════════════════════════════

@app.get("/items")
def get_items_api() -> list[ItemResponse]:
    with SessionFactory() as session:
        stmt = select(Item)
#───────────────────────────────────────────────────────────────────
# SQL 문 생성
#   - stmt = statement (SQL 문)
#   - select(Item) = SELECT * FROM items
#
# Q: 왜 바로 실행 안 하고 stmt 만들어?
# A: → SQLAlchemy 스타일: 먼저 쿼리 만들고 → 실행
#    → stmt에 .where(), .order_by() 등 추가 가능
#    → 쿼리를 조립하는 느낌!
#───────────────────────────────────────────────────────────────────

        items = session.scalars(stmt).all()
#───────────────────────────────────────────────────────────────────
# 쿼리 실행 및 결과 가져오기
#
# scalars(stmt):
#   - stmt 실행하고 결과 가져오기
#   - "scalar" = 단일 컬럼/객체
#   - Item 객체 리스트 형태로 반환
#
# .all():
#   - 모든 결과를 리스트로 가져옴
#   - [Item1, Item2, Item3, ...]
#
# Q: 왜 execute() 대신 scalars()?
# A: → execute()는 Row 객체 반환 (복잡함)
#    → scalars()는 바로 Item 객체 반환 (간편함)
#───────────────────────────────────────────────────────────────────

        return items


# ═══════════════════════════════════════════════════════════════════
# 🔵 R: Read - 단일 상품 조회 API
# ═══════════════════════════════════════════════════════════════════

@app.get("/items/{item_id}")
def get_item_api(item_id: int) -> ItemResponse:
    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
#───────────────────────────────────────────────────────────────────
# 조건부 SELECT
#   - select(Item).where(Item.id == item_id)
#   - = SELECT * FROM items WHERE id = ?
#   - Item.id == item_id: ORM 스타일 조건문
#───────────────────────────────────────────────────────────────────

        item: Item | None = session.scalar(stmt)
#───────────────────────────────────────────────────────────────────
# 단일 결과 가져오기
#
# scalar() vs scalars():
#   - scalar(): 단일 객체 반환 (없으면 None)
#   - scalars(): 여러 객체 반환 (리스트)
#
# Item | None:
#   - 찾으면 Item 객체
#   - 못 찾으면 None
#   - 타입 힌트로 명시해서 IDE가 None 체크 안내해줌
#───────────────────────────────────────────────────────────────────

        if item is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Item Not Found (id: {item_id})",
            )
#───────────────────────────────────────────────────────────────────
# 🔴 예외 처리 (왜? 꼬리물기)
#
# Q1: 왜 None 체크를 해?
# A1: → DB에 해당 id의 아이템이 없을 수 있음!
#     → 클라이언트가 /items/999 요청 → 999번 없음 → None
#
# Q2: None이면 왜 에러?
# A2: → 없는 걸 반환할 수 없음!
#     → "없다"고 명확히 알려줘야 클라이언트가 대응 가능
#
# Q3: 왜 404?
# A3: → HTTP 규약! "요청한 리소스 없음" = 404
#     → 브라우저, 앱 모두 404 = "없구나" 이해
#
# Q4: 이거 없으면?
# A4: → None 반환 → ItemResponse와 타입 불일치
#     → FastAPI가 500 에러 발생시킴
#     → 500은 "서버 잘못", 404는 "없음" → 의미가 다름!
#───────────────────────────────────────────────────────────────────

        return item


# ═══════════════════════════════════════════════════════════════════
# 🟡 U: Update - 상품 수정 API (PATCH: 부분 수정)
# ═══════════════════════════════════════════════════════════════════

@app.patch("/items/{item_id}", status_code=status.HTTP_200_OK)
def update_item_api(item_id: int, body: ItemUpdateRequest) -> ItemResponse:
#───────────────────────────────────────────────────────────────────
# PATCH: Partial Update (부분 수정)
#   - 일부 필드만 보내도 OK
#   - body.name이 None이면 수정 안 함
#───────────────────────────────────────────────────────────────────

    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
        item: Item | None = session.scalar(stmt)

        if item is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Item Not Found (id: {item_id})",
            )
#───────────────────────────────────────────────────────────────────
# 수정할 아이템 조회 + 없으면 404
# (위에서 설명한 패턴 동일!)
#───────────────────────────────────────────────────────────────────

        # 객체의 값을 변경하고, commit하여 DB에 반영
        if body.name:
            item.name = body.name
        if body.price:
            item.price = body.price
#───────────────────────────────────────────────────────────────────
# 부분 수정 로직
#
# Q: 왜 if문으로 감싸?
# A: → body.name이 None이면 수정 안 함!
#    → 클라이언트가 {"price": 200}만 보냈으면
#    → name은 그대로, price만 변경
#
# Q: item.name = ... 이렇게만 해도 DB가 바뀌어?
# A: → 아직 안 바뀜! 메모리의 객체만 변경된 상태
#    → commit() 해야 DB에 UPDATE 실행됨
#───────────────────────────────────────────────────────────────────

        session.commit()
#───────────────────────────────────────────────────────────────────
# 변경사항 DB에 반영
#   - SQLAlchemy가 자동으로 UPDATE 쿼리 생성
#   - UPDATE items SET name=?, price=? WHERE id=?
#───────────────────────────────────────────────────────────────────

        return item


# ═══════════════════════════════════════════════════════════════════
# 🟡 U: Update - 상품 수정 API (PUT: 전체 교체)
# ═══════════════════════════════════════════════════════════════════

@app.put("/items/{item_id}", status_code=200)
def replace_item_api(item_id: int, body: ItemReplaceRequest) -> ItemResponse:
#───────────────────────────────────────────────────────────────────
# PUT: Replace (전체 교체)
#   - 모든 필드 필수!
#   - 기존 데이터를 완전히 새 데이터로 교체
#───────────────────────────────────────────────────────────────────

    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
        item: Item | None = session.scalar(stmt)

        if item is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Item Not Found (id: {item_id})",
            )

        item.name = body.name
        item.price = body.price
#───────────────────────────────────────────────────────────────────
# 전체 교체 (PATCH와의 차이)
#
# PATCH: if body.name: item.name = body.name (조건부)
# PUT:   item.name = body.name (무조건)
#
# Q: 왜 if문 없어?
# A: → PUT은 전체 교체니까!
#    → body.name, body.price 둘 다 필수 (None 불가)
#    → 항상 값이 있으니까 if 체크 불필요
#───────────────────────────────────────────────────────────────────

        session.commit()
        return item


# ═══════════════════════════════════════════════════════════════════
# 🔴 D: Delete - 상품 삭제 API
# ═══════════════════════════════════════════════════════════════════

@app.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_item_api(item_id: int) -> None:
#───────────────────────────────────────────────────────────────────
# DELETE: 삭제
# status_code=204: No Content (본문 없이 성공)
#
# Q: 왜 204야?
# A: → 삭제 성공하면 반환할 데이터가 없음!
#    → 200 + 빈 응답도 가능하지만
#    → 204가 더 명확: "성공했고, 내용 없음"
#
# -> None:
#   → 반환값 없음을 명시
#   → 204 응답이니까 body가 비어있어야 함
#───────────────────────────────────────────────────────────────────

    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
        item: Item | None = session.scalar(stmt)

        if item is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Item Not Found (id: {item_id})",
            )

        session.delete(item)
#───────────────────────────────────────────────────────────────────
# 세션에서 삭제 표시
#
# Q: delete()가 뭐야?
# A: → "이 객체를 DB에서 삭제할 거야" 표시
#    → 아직 삭제 안 됨! (대기 상태)
#    → commit() 해야 실제 DELETE 실행
#
# add() ↔ delete() 대응:
#   - add(): INSERT할 객체 등록
#   - delete(): DELETE할 객체 등록
#───────────────────────────────────────────────────────────────────

        session.commit()
#───────────────────────────────────────────────────────────────────
# DB에서 실제 삭제
#   - DELETE FROM items WHERE id = ?
#   - 영구적으로 삭제됨 (복구 불가!)
#───────────────────────────────────────────────────────────────────

# 반환값 없음 (204 No Content)
```

### 🔗 파일 연결 확인

```
crud.py가 사용하는 파일들:
├── from connection import SessionFactory  →  connection.py
├── from models import Item                →  models.py
└── models.py                              →  orm.py (Base 상속)
```

### 🚀 실행 방법

```bash
# 1. 먼저 테이블 생성 (최초 1회만)
python typing_prompt.py

# 2. 서버 실행
fastapi dev crud.py

# 3. API 문서 확인
# 브라우저에서 http://127.0.0.1:8000/docs 접속
```

### 📊 API 엔드포인트 요약

| 메서드 | 경로 | 기능 | 상태 코드 |
|--------|------|------|----------|
| POST | `/items` | 상품 등록 | 201 Created |
| GET | `/items` | 전체 조회 | 200 OK |
| GET | `/items/{id}` | 단일 조회 | 200 OK / 404 |
| PATCH | `/items/{id}` | 부분 수정 | 200 OK / 404 |
| PUT | `/items/{id}` | 전체 교체 | 200 OK / 404 |
| DELETE | `/items/{id}` | 삭제 | 204 No Content / 404 |



## 📄 6. 과제.py

### 📌 파일 설명
> **PUT 메서드**를 학습하기 위한 API입니다.  
> PATCH와의 차이점을 이해하는 것이 목표입니다.

### 📝 전체 코드

```python
#  put

from fastapi import FastAPI, HTTPException, status
#───────────────────────────────────────────────────────────────────
# status: HTTP 상태 코드 상수 모듈
#   - status.HTTP_200_OK → 200
#   - status.HTTP_404_NOT_FOUND → 404
#   - 숫자 대신 이름으로 쓰면 가독성 향상
#───────────────────────────────────────────────────────────────────

from pydantic import BaseModel
app = FastAPI()

items = [
    {"id": 1, "name":"apple", "price":100},
    {"id": 2, "name":"banana", "price":120},
    {"id": 3, "name":"cherry", "price":80},
]

class Item_Put_Request(BaseModel):
    name: str
    price: int
#───────────────────────────────────────────────────────────────────
# PUT 요청 스키마
#   - name: str (필수!)
#   - price: int (필수!)
#
# PATCH와의 차이:
#   - PATCH: name: str | None = None (선택)
#   - PUT: name: str (필수)
#
# PUT은 "전체 교체"이므로 모든 필드 필수
#───────────────────────────────────────────────────────────────────

class Item_Put_Response(BaseModel):
    name: str
    price: int
#───────────────────────────────────────────────────────────────────
# PUT 응답 스키마
#   - 수정된 아이템의 name, price 반환
#───────────────────────────────────────────────────────────────────

@app.put("/items/{item_id}", status_code=status.HTTP_200_OK)
def update_item_api(item_id: int, body: Item_Put_Request) -> Item_Put_Response:
#───────────────────────────────────────────────────────────────────
# @app.put: PUT 메서드 (전체 교체)
#
# status_code=status.HTTP_200_OK:
#   - 성공시 200 반환
#   - 숫자(200) 대신 상수 사용 → 가독성 향상
#───────────────────────────────────────────────────────────────────

    for item in items:
        if item["id"] == item_id:
            item["name"] = body.name
            item["price"] = body.price
            return item
#───────────────────────────────────────────────────────────────────
# 전체 교체 로직
#   - if문 없이 무조건 덮어쓰기
#   - name, price 모두 교체
#
# PATCH와의 차이:
#   - PATCH: if body.name: item["name"] = body.name (조건부)
#   - PUT: item["name"] = body.name (무조건)
#───────────────────────────────────────────────────────────────────

# PUT과 PATCH 차이점:
# - PUT: 전체 필드 필수 + 무조건 교체
# - PATCH: Optional 필드 + 조건부 수정

    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail = f"Item is not Found(id: {item_id})"
    )
#───────────────────────────────────────────────────────────────────
# 🔴 PUT에서의 예외 처리 (status 상수 버전)
#
# Q1: 왜 404 대신 status.HTTP_404_NOT_FOUND 써?
# A1: → 둘 다 똑같이 404야!
#     → 근데 status.HTTP_404_NOT_FOUND가 더 읽기 좋음
#     → 코드만 봐도 "아, 404 Not Found구나" 바로 이해
#     → 404라고만 쓰면 "404가 뭐였지?" 헷갈릴 수 있음
#
# Q2: PUT은 "전체 교체"인데, 없으면 새로 만들면 안 돼?
# A2: → 그것도 방법이야! (이걸 "Upsert"라고 함)
#     → 근데 지금은 학습용이라 단순하게:
#        "있으면 수정, 없으면 에러"
#     → 실무에선 요구사항에 따라 다르게 구현
#
# Q3: 이 코드 위치가 왜 for문 바깥이야?
# A3: → for문 안에서 return item 했잖아?
#     → 찾으면 바로 return해서 함수 끝!
#     → for문 끝까지 왔다 = return 못 함 = 못 찾음
#     → 그래서 for문 끝나고 raise 실행
#
# 📌 for-return-raise 패턴:
#   for item in items:        ← 하나씩 검사
#       if 조건:              ← 찾았나?
#           return item       ← 찾으면 즉시 반환 (함수 종료)
#   raise HTTPException(...)  ← 못 찾으면 여기 도달 → 에러!
#───────────────────────────────────────────────────────────────────

# def update_item_api(item_id: int, body: Item_Put_Request): 요청

# for item in items: 처리

# Item_Put_Response: 응답(처리한 부분을 검사해서 전달)
```

### 🔀 PUT vs PATCH 비교

| 구분 | PUT | PATCH |
|------|-----|-------|
| **목적** | 전체 교체 | 부분 수정 |
| **필드** | 모두 필수 | 선택적 (Optional) |
| **요청 스키마** | `name: str`, `price: int` | `name: str \| None = None` |
| **수정 로직** | 무조건 덮어쓰기 | if문으로 조건부 수정 |
| **예시** | 아이템 정보 완전 교체 | 가격만 변경 |

---

## 🎯 핵심 개념 정리

### 1️⃣ ORM (Object-Relational Mapping)
```
Python 클래스 ←→ DB 테이블
Python 객체  ←→ DB 행(row)
클래스 속성  ←→ DB 컬럼
```

### 2️⃣ Pydantic 스키마
```
Request 스키마: 클라이언트 → 서버 (입력 검증)
Response 스키마: 서버 → 클라이언트 (출력 검증)
```

### 3️⃣ HTTP 메서드
```
POST   → Create (생성)
GET    → Read (조회)
PUT    → Update 전체 교체
PATCH  → Update 부분 수정
DELETE → Delete (삭제)
```

### 4️⃣ 실행 흐름
```
1. orm.py      → Base 정의
2. models.py   → Item 모델 정의 (Base 상속)
3. connection.py → engine 생성
4. typing_prompt.py → 테이블 생성 (create_all)
5. crud.py / 과제.py → API 서버 실행
```

