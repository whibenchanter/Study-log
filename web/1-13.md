# 📚 1.13 - Pydantic과 Request/Response Body 학습

> **핵심 목표**: FastAPI에서 **Pydantic**을 사용하여 요청(Request)과 응답(Response) 데이터를 검증하고 직렬화하는 방법을 배운다.

---

## 📋 파일 요약

| 파일명 | 핵심 내용 | 학습 순서 |
|--------|----------|-----------|
| `type_hints.py` | Python 타입 힌트 문법 기초 | 1️⃣ |
| `pydantic_practice.py` | Pydantic BaseModel 기본 사용법 | 2️⃣ |
| `request_body.py` | Request Body로 요청 데이터 검증 | 3️⃣ |
| `response_body.py` | Response Body로 응답 데이터 형식 지정 | 4️⃣ |
| `과제.py` | Request + Response + 에러처리 종합 실습 | 5️⃣ |

---

## 🔤 1. type_hints.py - 타입 힌트 기초

### 📝 이 파일은 뭘 하는 파일인가?
Python의 **타입 힌트(Type Hints)** 문법을 연습하는 파일입니다. Pydantic을 사용하기 전에 Python의 타입 표기법을 이해해야 합니다.

### 💻 전체 코드
```python
# 퀴즈
users: list[dict[str, int | str]] = [
    {"id": 1, "email": "alex@gmail.com"},
    {"id": 2, "email": "bob@gmail.com"},
    {"id": 3, "email": "chris@gmail.com"},
]
```

### 🔍 한 줄씩 완벽 분석

```python
# 퀴즈
```

---

```python
users: list[dict[str, int | str]] = [
```

| 부분 | 의미 |
|------|------|
| `users` | 변수 이름 |
| `:` | 타입 힌트 시작 |
| `list[...]` | 리스트 타입, 안에 들어갈 요소 타입을 `[]` 안에 명시 |
| `dict[str, int \| str]` | 딕셔너리 타입. 키는 `str`, 값은 `int` 또는 `str` |
| `int \| str` | **Union 타입** - int이거나 str이거나 둘 다 가능 (Python 3.10+) |
| `= [` | 실제 값 할당 시작 |

**쉽게 말하면**: "users는 딕셔너리들의 리스트인데, 각 딕셔너리의 키는 문자열이고 값은 정수 또는 문자열이다"

---

```python
    {"id": 1, "email": "alex@gmail.com"},
```
- `"id"` → 키(str), `1` → 값(int) ✅
- `"email"` → 키(str), `"alex@gmail.com"` → 값(str) ✅
- 타입 힌트 `dict[str, int | str]`에 완벽히 부합!

---

## 🏗️ 2. pydantic_practice.py - Pydantic 기초

### 📝 이 파일은 뭘 하는 파일인가?
**Pydantic**의 `BaseModel`을 사용하여 데이터 형식을 정의하고, FastAPI에서 Request Body를 검증하는 기본 패턴을 배웁니다.

### 💻 전체 코드
```python
from fastapi import FastAPI
from pydantic import BaseModel, Field

# # Pydantic -> "내가 원하는 데이터 형식을 표현"
# class Item(BaseModel):
#     name: str
#     price: int

# # 1. BaseModel을 이용해서 데이터를 class로 표현한다
# # 2. 검증하고자 하는 데이터를 class에 넣어본다.
# #    class(...) / class.model_validate(dict)
# # 3. 검증이 통과하면, 데이터를 사용
# # 4. 실패하면, 에러처리 #

app = FastAPI()

# Request Body: 데이터의 형식을 표현 -> Pydantic
# 예: 회원가입 {email: "", password: ""}

# xxxRequest
class ItemCreateRequest(BaseModel):
    name: str
    price: int


# 상품 등록 API
@app.post("/items")
def create_item_api(body: ItemCreateRequest):
    return{"name": body.name, "price": body.price}
```

### 🔍 한 줄씩 완벽 분석

```python
from fastapi import FastAPI
```
- FastAPI 프레임워크의 핵심 클래스를 가져옴
- 이걸로 웹 애플리케이션 인스턴스를 만듦

---

```python
from pydantic import BaseModel, Field
```

| import | 역할 |
|--------|------|
| `BaseModel` | 데이터 모델을 정의하는 기본 클래스 |
| `Field` | 필드에 추가 설정(기본값, 설명, 제약 등)을 넣을 때 사용 |

---

```python
app = FastAPI()
```
- FastAPI 애플리케이션 인스턴스 생성
- 모든 라우트는 이 `app`에 등록됨

---

```python
class ItemCreateRequest(BaseModel):
    name: str
    price: int
```

| 부분 | 의미 |
|------|------|
| `class ItemCreateRequest` | 클래스 이름. `xxxRequest` 패턴은 요청 데이터임을 명시 |
| `(BaseModel)` | Pydantic의 BaseModel을 상속 → 자동 검증 기능 획득! |
| `name: str` | name 필드는 반드시 문자열이어야 함 |
| `price: int` | price 필드는 반드시 정수여야 함 |

**Pydantic의 마법**: 이 클래스로 데이터를 생성하면 자동으로 타입 검증!
```python
ItemCreateRequest(name="사과", price=1000)  # ✅ 성공
ItemCreateRequest(name="사과", price="천원")  # ❌ 에러! price는 int여야 함
```

---

```python
@app.post("/items")
```
- **데코레이터**: 아래 함수를 HTTP POST `/items` 경로에 연결
- POST = 새로운 데이터 생성 (Create)

---

```python
def create_item_api(body: ItemCreateRequest):
```

| 부분 | 의미 |
|------|------|
| `body` | 매개변수 이름 (원하는 이름 사용 가능) |
| `: ItemCreateRequest` | **핵심!** FastAPI가 이걸 보고 자동으로 Request Body를 파싱하고 검증 |

**FastAPI 동작 원리**:
1. 클라이언트가 JSON 전송 → `{"name": "사과", "price": 1000}`
2. FastAPI가 자동으로 `ItemCreateRequest` 객체로 변환
3. 타입이 안 맞으면? 자동으로 422 에러 응답!

---

```python
    return{"name": body.name, "price": body.price}
```
- `body.name` → 검증된 데이터에서 name 값 추출
- `body.price` → 검증된 데이터에서 price 값 추출
- 딕셔너리를 반환하면 FastAPI가 자동으로 JSON 변환

---

## 📥 3. request_body.py - Request Body 심화

### 📝 이 파일은 뭘 하는 파일인가?
Request Body에 **Optional 필드**를 추가하는 방법을 배웁니다. 모든 필드가 필수가 아닐 수 있음!

### 💻 전체 코드
```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class ItemCreateRequest(BaseModel):
    name: str
    price: int
    description: str | None = None  # (str~ 이부분은 옵셔널하다는 뜻)

# 상품등록
@app.post("/items")
def create_item_api(body: ItemCreateRequest):
    return {"name": body.name, "price": body.price}
    # body를 통해서 데이터가 알아서 형식에 맞는지 검증이 되고있음
```

### 🔍 핵심 분석 - Optional 필드

```python
    description: str | None = None
```

이 한 줄이 이 파일의 핵심!

| 부분 | 의미 |
|------|------|
| `description` | 필드 이름 |
| `str \| None` | 문자열이거나 None(없음)이거나 |
| `= None` | 기본값이 None → **필수가 아님!** |

**실제 요청 예시**:
```json
// ✅ description 있음
{"name": "사과", "price": 1000, "description": "맛있는 사과"}

// ✅ description 없음 (Optional이니까 OK!)
{"name": "사과", "price": 1000}

// ❌ 에러! name과 price는 필수
{"description": "설명만"}
```

---

## 📤 4. response_body.py - Response Body

### 📝 이 파일은 뭘 하는 파일인가?
**Response Body**를 정의하여 응답 데이터의 형식을 지정합니다. 민감한 정보(비밀번호 등)가 응답에 노출되지 않도록 제어!

### 💻 전체 코드
```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

# pydantic -> 데이터의 형식을 보장
class UserSignUpResponse(BaseModel):
    id: int
    email: str  # 패스워드 여기 선언 안됐으므로 밑에서 return해도 노출 x

# 회원가입 API
@app.post("/users/sign-up", status_code=201)
def sign_up_api(body: UserSignUpResponse) -> UserSignUpResponse:
    # 이메일 중복검사 & db 저장
    return {
        "id": 1,
        "email": body.email,
    }
```

### 🔍 한 줄씩 완벽 분석

```python
class UserSignUpResponse(BaseModel):
    id: int
    email: str
```
- Response 모델에는 `id`와 `email`만 있음
- **password가 없다!** → 응답에 절대 포함되지 않음 (보안!)

---

```python
@app.post("/users/sign-up", status_code=201)
```

| 부분 | 의미 |
|------|------|
| `"/users/sign-up"` | 회원가입 엔드포인트 경로 |
| `status_code=201` | 성공 시 201 Created 반환 (리소스 생성됨) |

**HTTP 상태 코드**:
- 200: OK (기본)
- 201: Created (새 리소스 생성)
- 400: Bad Request
- 404: Not Found

---

```python
def sign_up_api(body: UserSignUpResponse) -> UserSignUpResponse:
```

| 부분 | 의미 |
|------|------|
| `body: UserSignUpResponse` | 요청 데이터 타입 |
| `-> UserSignUpResponse` | **반환 타입 명시** → FastAPI가 응답 형식 검증 |

**Response Model의 힘**:
```python
# 만약 이렇게 반환해도...
return {"id": 1, "email": "test@test.com", "password": "secret123"}

# Response 모델에 password가 없으므로 실제 응답은:
{"id": 1, "email": "test@test.com"}  # password 자동 제거!
```

---

## 🎯 5. 과제.py - 종합 실습

### 📝 이 파일은 뭘 하는 파일인가?
Request Body, Response Body, 에러 처리를 모두 활용한 종합 예제입니다.

### 💻 전체 코드
```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class HelloRequest(BaseModel):
    name: str

class HelloResponse(BaseModel):
    message: str

@app.post("/hello")
def hello_api(body: HelloRequest) -> HelloResponse:
    if body.name.strip() == "":
        raise HTTPException(status_code=400, detail="이름을 입력해주세요!")
    return {"message": f"안녕하세요, {body.name}님!"}


# strip() : 공백 제거
# **요청:** `{"name": "민수"}`
# **응답:** `{"message": "안녕하세요, 민수님!"}`
```

### 🔍 한 줄씩 완벽 분석

```python
from fastapi import FastAPI, HTTPException
```

| import | 역할 |
|--------|------|
| `FastAPI` | 앱 생성 |
| `HTTPException` | HTTP 에러를 발생시키는 예외 클래스 |

---

```python
class HelloRequest(BaseModel):
    name: str
```
- 요청에는 `name`(문자열)이 반드시 필요

---

```python
class HelloResponse(BaseModel):
    message: str
```
- 응답은 `message`(문자열) 형식

---

```python
@app.post("/hello")
def hello_api(body: HelloRequest) -> HelloResponse:
```
- POST `/hello` 엔드포인트
- 요청: `HelloRequest`, 응답: `HelloResponse`

---

```python
    if body.name.strip() == "":
```

| 메서드 | 동작 |
|--------|------|
| `strip()` | 문자열 앞뒤 공백 제거 |
| `== ""` | 공백 제거 후 빈 문자열인지 확인 |

**예시**:
```python
"  ".strip()      # → "" (공백만 있으면 빈 문자열)
" 민수 ".strip()  # → "민수" (앞뒤 공백 제거)
```

---

```python
        raise HTTPException(status_code=400, detail="이름을 입력해주세요!")
```

| 부분 | 의미 |
|------|------|
| `raise` | 예외 발생 (함수 즉시 종료) |
| `HTTPException` | HTTP 에러 응답 생성 |
| `status_code=400` | Bad Request (잘못된 요청) |
| `detail="..."` | 에러 메시지 |

**실제 응답**:
```json
{
    "detail": "이름을 입력해주세요!"
}
```

---

```python
    return {"message": f"안녕하세요, {body.name}님!"}
```
- f-string으로 동적 메시지 생성
- 요청 `{"name": "민수"}` → 응답 `{"message": "안녕하세요, 민수님!"}`

---

## 🎓 핵심 정리

### Pydantic + FastAPI 동작 흐름

| 순서 | 단계 | 설명 |
|:---:|------|------|
| 📨 | **클라이언트 요청** | `{"name": "사과", "price": 1000}` |
| ↓ | 1. JSON 파싱 | 문자열 → 딕셔너리 |
| ↓ | 2. Pydantic 변환 | 딕셔너리 → `ItemCreateRequest` 객체 |
| ↓ | 3. 타입 검증 | 자동으로 타입 체크 |
| ↓ | 4. 함수 실행 | `create_item_api()` 호출 |
| ↓ | 5. Response 필터링 | Response 모델에 맞게 응답 생성 |
| 📤 | **응답** | `{"name": "사과", "price": 1000}` |

### 기억해야 할 패턴

| 패턴 | 용도 | 예시 |
|------|------|------|
| `xxxRequest` | 요청 데이터 모델 | `ItemCreateRequest` |
| `xxxResponse` | 응답 데이터 모델 | `UserSignUpResponse` |
| `str \| None = None` | Optional 필드 | 선택적 입력 |
| `-> ResponseModel` | 반환 타입 지정 | 응답 형식 보장 |
| `HTTPException` | 에러 응답 | 유효성 검사 실패 시 |
