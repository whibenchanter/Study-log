# 📚 FastAPI + SQLAlchemy CRUD 학습 정리 (1.15)

> **목표**: FastAPI와 SQLAlchemy ORM을 활용한 CRUD API 구현 및 비동기 프로그래밍 이해

---

## 📁 파일 구조 및 연결 관계

```
1.15/
├── orm.py            # 1️⃣ ORM 기반 클래스 (Base)
├── connection.py     # 2️⃣ 데이터베이스 연결 설정
├── models.py         # 3️⃣ 데이터 모델 정의 (Item)
├── crud_session.py   # 4️⃣ 메인 FastAPI 서버 (CRUD API)
├── 과제115.py         # 5️⃣ 비동기 프로그래밍 과제
├── practice.py       # 6️⃣ 비동기 연습
├── sync.py           # 7️⃣ 동기 vs 비동기 비교
└── test.db           # 📦 SQLite 데이터베이스 파일 (자동생성)
```

### 🔗 파일 의존성 다이어그램

```
crud_session.py (메인)
    ├── connection.py → SessionFactory, engine
    ├── models.py → Item
    └── orm.py → create_tables()
           │
models.py ──┘
    └── orm.py → Base
           │
connection.py ←─┘ (create_tables에서 engine 사용)
```

---

# 1️⃣ orm.py - ORM 기반 클래스

> **역할**: SQLAlchemy ORM의 기반이 되는 Base 클래스 정의

```python
from sqlalchemy.orm import DeclarativeBase
# ┌────────────────────────────────────────────────────────────────┐
# │ DeclarativeBase란?                                              │
# │ - SQLAlchemy 2.0에서 도입된 새로운 ORM 기반 클래스               │
# │ - 이 클래스를 상속받은 모든 클래스는 자동으로 DB 테이블과 매핑됨   │
# │ - 내부적으로 metadata를 관리하여 테이블 정보를 저장               │
# └────────────────────────────────────────────────────────────────┘

class Base(DeclarativeBase):
    pass
# ┌────────────────────────────────────────────────────────────────┐
# │ Base 클래스                                                     │
# │ - 우리가 만들 모든 모델(Item 등)은 이 Base를 상속받음             │
# │ - Base.metadata에 모든 테이블 정보가 자동으로 등록됨              │
# │ - 예: Item(Base)를 정의하면 → Base.metadata에 items 테이블 등록  │
# └────────────────────────────────────────────────────────────────┘

# 테이블 생성 함수
def create_tables():
    from connection import engine
    # ┌────────────────────────────────────────────────────────────┐
    # │ 왜 함수 안에서 import 하는가? (지연 import)                  │
    # │                                                            │
    # │ 문제 상황 (순환 참조):                                       │
    # │   orm.py → connection.py (engine 필요)                     │
    # │   connection.py → orm.py (Base 필요할 수 있음)              │
    # │                                                            │
    # │ 해결: 함수가 호출될 때만 import하면 순환 참조 방지!           │
    # └────────────────────────────────────────────────────────────┘
    
    Base.metadata.create_all(bind=engine)
    # ┌────────────────────────────────────────────────────────────┐
    # │ Base.metadata.create_all(bind=engine)                       │
    # │                                                            │
    # │ metadata: Base를 상속받은 모든 모델의 테이블 정보 저장소      │
    # │ create_all(): metadata에 등록된 모든 테이블을 실제 DB에 생성 │
    # │ bind=engine: 어떤 DB에 생성할지 지정                        │
    # │                                                            │
    # │ ⚠️ 중요: 이미 존재하는 테이블은 건드리지 않음 (안전함)        │
    # └────────────────────────────────────────────────────────────┘
```

---

# 2️⃣ connection.py - 데이터베이스 연결 설정

> **역할**: SQLAlchemy 엔진과 세션 팩토리 생성

```python
from sqlalchemy import create_engine
# ┌────────────────────────────────────────────────────────────────┐
# │ create_engine: DB 연결을 담당하는 엔진 생성 함수                 │
# │ - 엔진은 DB와의 "연결 풀"을 관리                                │
# │ - 실제 SQL을 실행하는 핵심 객체                                 │
# └────────────────────────────────────────────────────────────────┘

from sqlalchemy.orm import sessionmaker
# ┌────────────────────────────────────────────────────────────────┐
# │ sessionmaker: 세션을 생성하는 "공장(Factory)"을 만드는 함수      │
# │ - 세션은 DB와의 "대화 단위"                                     │
# │ - 하나의 세션 = 하나의 트랜잭션 (작업 묶음)                      │
# └────────────────────────────────────────────────────────────────┘

# 데이터베이스 접속 정보
DATABASE_URL = "sqlite:///./test.db"
# ┌────────────────────────────────────────────────────────────────┐
# │ SQLite 연결 문자열 형식:                                        │
# │                                                                │
# │   sqlite:///./test.db                                          │
# │   ├─────┤├─┤├───────┤                                          │
# │      │    │     └── 파일 경로 (현재 디렉토리의 test.db)          │
# │      │    └── 슬래시 3개 = 상대경로 시작                         │
# │      └── DB 종류                                               │
# │                                                                │
# │ 다른 DB 예시:                                                   │
# │ - PostgreSQL: postgresql://user:pass@localhost:5432/dbname     │
# │ - MySQL: mysql://user:pass@localhost:3306/dbname               │
# └────────────────────────────────────────────────────────────────┘

# 엔진(Engine) = SQLAlchemy 사용시 DB와 연결관리
engine = create_engine(DATABASE_URL)
# ┌────────────────────────────────────────────────────────────────┐
# │ engine 객체의 역할:                                             │
# │ 1. DB 연결 풀(Connection Pool) 관리                            │
# │ 2. SQL 문 실행                                                 │
# │ 3. 트랜잭션 관리                                                │
# │                                                                │
# │ 비유: engine = "DB와 통화할 수 있는 전화기"                      │
# └────────────────────────────────────────────────────────────────┘

# 세션(Session) = DB 작업관리
# 세션을 만들 수 있는 세션 팩토리
SessionFactory = sessionmaker(
    bind=engine,
    # ┌────────────────────────────────────────────────────────────┐
    # │ bind=engine: 이 세션이 어떤 DB에 연결될지 지정               │
    # └────────────────────────────────────────────────────────────┘
    
    autocommit=False,
    # ┌────────────────────────────────────────────────────────────┐
    # │ autocommit=False (기본값)                                   │
    # │ - 수동으로 commit()을 호출해야 DB에 반영됨                   │
    # │ - 실수로 저장되는 것을 방지 (안전)                           │
    # │ - True면: 모든 SQL이 즉시 DB에 반영 (위험!)                  │
    # └────────────────────────────────────────────────────────────┘
    
    autoflush=False,
    # ┌────────────────────────────────────────────────────────────┐
    # │ autoflush=False                                            │
    # │ - flush: 메모리의 변경사항을 DB에 "임시 전송" (commit 전)    │
    # │ - False: 명시적으로 flush/commit 할 때만 전송               │
    # │ - True면: 쿼리 실행 전 자동으로 flush (예상치 못한 동작 가능)│
    # └────────────────────────────────────────────────────────────┘
    
    expire_on_commit=False,
    # ┌────────────────────────────────────────────────────────────┐
    # │ expire_on_commit=False ⭐ 중요!                             │
    # │                                                            │
    # │ True (기본값):                                              │
    # │   commit() 후 객체의 모든 속성이 "만료"됨                    │
    # │   → 속성 접근 시 DB에서 다시 조회 필요                       │
    # │   → 세션이 닫히면 객체 속성 접근 불가! (DetachedInstanceError)│
    # │                                                            │
    # │ False (우리 설정):                                          │
    # │   commit() 후에도 객체의 속성값 유지                         │
    # │   → 세션이 닫혀도 객체 사용 가능                             │
    # │   → API 응답으로 객체 반환 시 필수!                          │
    # │                                                            │
    # │ 예시:                                                       │
    # │   with SessionFactory() as session:                        │
    # │       item = Item(name="사과", price=1000)                  │
    # │       session.add(item)                                    │
    # │       session.commit()                                     │
    # │       return item  # ← expire_on_commit=False여야 작동!    │
    # └────────────────────────────────────────────────────────────┘
)
```

---

# 3️⃣ models.py - 데이터 모델 정의

> **역할**: DB 테이블과 매핑되는 ORM 모델 클래스 정의

```python
from orm import Base
# ┌────────────────────────────────────────────────────────────────┐
# │ Base를 상속받아 ORM 모델을 만들 준비                             │
# │ Base를 상속받는 순간, 이 클래스는 DB 테이블과 연결됨             │
# └────────────────────────────────────────────────────────────────┘

from sqlalchemy import Integer, String
# ┌────────────────────────────────────────────────────────────────┐
# │ SQLAlchemy의 컬럼 타입들                                        │
# │ - Integer: 정수형 (SQL의 INTEGER)                              │
# │ - String(n): 문자열 (SQL의 VARCHAR(n))                         │
# │ - 다른 타입: Float, Boolean, DateTime, Text 등                 │
# └────────────────────────────────────────────────────────────────┘

from sqlalchemy.orm import Mapped, mapped_column
# ┌────────────────────────────────────────────────────────────────┐
# │ SQLAlchemy 2.0 스타일의 컬럼 정의 도구                          │
# │                                                                │
# │ Mapped[타입]: 파이썬 타입힌트와 ORM을 연결                       │
# │ mapped_column(): 컬럼의 세부 설정 (타입, 제약조건 등)            │
# │                                                                │
# │ 이전 방식 (1.x):                                                │
# │   id = Column(Integer, primary_key=True)                       │
# │                                                                │
# │ 새로운 방식 (2.0):                                              │
# │   id: Mapped[int] = mapped_column(Integer, primary_key=True)   │
# └────────────────────────────────────────────────────────────────┘

# Item 데이터를 저장할 DB 테이블 & ORM 객체
class Item(Base):
    # ┌────────────────────────────────────────────────────────────┐
    # │ Base를 상속받음 → 자동으로 Base.metadata에 등록됨            │
    # │ → create_tables() 호출 시 이 테이블도 생성됨                 │
    # └────────────────────────────────────────────────────────────┘
    
    __tablename__ = "items"
    # ┌────────────────────────────────────────────────────────────┐
    # │ 실제 DB에 생성될 테이블 이름                                 │
    # │ - 클래스명: Item (파이썬 코드에서 사용)                      │
    # │ - 테이블명: items (DB에서 사용)                              │
    # │ - 관례: 클래스는 단수, 테이블은 복수형                        │
    # └────────────────────────────────────────────────────────────┘

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    # ┌────────────────────────────────────────────────────────────┐
    # │ id 컬럼 정의                                                │
    # │                                                            │
    # │ Mapped[int]: 파이썬에서는 int 타입으로 사용                  │
    # │ Integer: DB에서는 INTEGER 타입                              │
    # │ primary_key=True: 기본키 (자동 증가, 고유값)                 │
    # │                                                            │
    # │ 기본키(Primary Key)란?                                      │
    # │ - 각 행(row)을 고유하게 식별하는 컬럼                        │
    # │ - 중복 불가, NULL 불가                                      │
    # │ - SQLite에서는 자동으로 AUTOINCREMENT됨                     │
    # └────────────────────────────────────────────────────────────┘
    
    name: Mapped[str] = mapped_column(String(128))
    # ┌────────────────────────────────────────────────────────────┐
    # │ name 컬럼 정의                                              │
    # │                                                            │
    # │ Mapped[str]: 파이썬에서는 str 타입                          │
    # │ String(128): DB에서는 VARCHAR(128) - 최대 128자             │
    # └────────────────────────────────────────────────────────────┘
    
    price: Mapped[int] = mapped_column(Integer)
    # ┌────────────────────────────────────────────────────────────┐
    # │ price 컬럼 정의                                             │
    # │                                                            │
    # │ Mapped[int]: 파이썬에서는 int 타입                          │
    # │ Integer: DB에서는 INTEGER 타입                              │
    # └────────────────────────────────────────────────────────────┘

# ┌────────────────────────────────────────────────────────────────────┐
# │ 💡 ORM의 마법                                                      │
# │                                                                    │
# │ 파이썬 객체:           ←→      DB 테이블:                          │
# │ ┌─────────────────┐           ┌─────────────────────────────┐     │
# │ │ Item(           │           │ items 테이블                 │     │
# │ │   id=1,         │    ===    │ ┌────┬────────┬───────┐     │     │
# │ │   name="사과",  │           │ │ id │ name   │ price │     │     │
# │ │   price=1000    │           │ ├────┼────────┼───────┤     │     │
# │ │ )               │           │ │ 1  │ 사과   │ 1000  │     │     │
# │ └─────────────────┘           │ └────┴────────┴───────┘     │     │
# │                               └─────────────────────────────┘     │
# └────────────────────────────────────────────────────────────────────┘
```

---

# 4️⃣ crud_session.py - 메인 FastAPI CRUD API

> **역할**: FastAPI를 사용한 RESTful CRUD API 서버

```python
from contextlib import asynccontextmanager
# ┌────────────────────────────────────────────────────────────────┐
# │ asynccontextmanager: 비동기 컨텍스트 매니저를 만드는 데코레이터  │
# │ - FastAPI의 lifespan(수명주기) 관리에 사용                      │
# │ - 앱 시작/종료 시 실행할 코드를 정의                            │
# └────────────────────────────────────────────────────────────────┘

from fastapi import FastAPI, HTTPException, status
# ┌────────────────────────────────────────────────────────────────┐
# │ FastAPI: 웹 API 프레임워크의 핵심 클래스                        │
# │ HTTPException: HTTP 오류 응답을 발생시키는 예외                  │
# │ status: HTTP 상태 코드 상수 모음 (예: HTTP_204_NO_CONTENT)      │
# └────────────────────────────────────────────────────────────────┘

from pydantic import BaseModel
# ┌────────────────────────────────────────────────────────────────┐
# │ BaseModel: 요청/응답 데이터의 형식을 정의하는 기반 클래스        │
# │ - 자동 유효성 검사 (타입 체크)                                  │
# │ - 자동 JSON 변환                                               │
# │ - 자동 API 문서 생성                                           │
# └────────────────────────────────────────────────────────────────┘

from sqlalchemy import select
# ┌────────────────────────────────────────────────────────────────┐
# │ select: SQL SELECT 문을 만드는 함수                             │
# │ - select(Item) → SELECT * FROM items                           │
# │ - select(Item).where(...) → SELECT * FROM items WHERE ...      │
# └────────────────────────────────────────────────────────────────┘

from connection import SessionFactory
# └── DB 세션을 생성하는 팩토리

from models import Item
# └── Item ORM 모델

from orm import create_tables
# └── 테이블 생성 함수


@asynccontextmanager
async def lifespan(app: FastAPI):
    # ┌────────────────────────────────────────────────────────────┐
    # │ lifespan: 앱의 "수명주기"를 관리하는 함수                    │
    # │                                                            │
    # │ 실행 순서:                                                  │
    # │ 1. 앱 시작 시: yield 이전 코드 실행                          │
    # │ 2. 앱 실행 중: yield에서 대기                                │
    # │ 3. 앱 종료 시: yield 이후 코드 실행                          │
    # └────────────────────────────────────────────────────────────┘
    
    # 앱 시작 시 테이블 생성
    create_tables()
    # ┌────────────────────────────────────────────────────────────┐
    # │ 앱이 시작될 때 한 번만 실행됨                                │
    # │ → DB에 items 테이블이 없으면 생성                           │
    # │ → 이미 있으면 아무 일도 안 함 (안전)                         │
    # └────────────────────────────────────────────────────────────┘
    
    yield
    # └── 앱이 실행되는 동안 여기서 대기
    
    # 앱 종료 시 정리 작업 (필요시)
    # └── DB 연결 종료, 리소스 정리 등을 여기에 작성

app = FastAPI(lifespan=lifespan)
# ┌────────────────────────────────────────────────────────────────┐
# │ FastAPI 앱 생성                                                │
# │ - lifespan=lifespan: 수명주기 함수 연결                         │
# │ - 이 app 객체에 라우트(API 엔드포인트)를 등록                    │
# └────────────────────────────────────────────────────────────────┘
```

## 📤 응답 스키마 정의

```python
class ItemResponse(BaseModel):
    id: int
    name: str
    price: int
# ┌────────────────────────────────────────────────────────────────┐
# │ API 응답의 형식을 정의                                          │
# │                                                                │
# │ 왜 필요한가?                                                    │
# │ 1. 클라이언트에게 어떤 데이터가 반환되는지 명확히 알림           │
# │ 2. 자동으로 JSON 형태로 변환됨                                  │
# │ 3. Swagger 문서에 응답 형식이 표시됨                            │
# │                                                                │
# │ Item(ORM 모델)과 ItemResponse(응답 스키마)를 분리하는 이유:     │
# │ - ORM 모델: DB 테이블과 1:1 매핑 (내부용)                       │
# │ - Response: 클라이언트에게 보여줄 데이터만 선택 (외부용)         │
# │ - 보안상 민감한 정보(비밀번호 등)를 숨길 수 있음                 │
# └────────────────────────────────────────────────────────────────┘
```

## ✏️ Create (생성) - POST /items

```python
# C: 상품 등록 API
class ItemCreateRequest(BaseModel):
    name: str
    price: int
# ┌────────────────────────────────────────────────────────────────┐
# │ 상품 생성 요청 시 필요한 데이터                                  │
# │ - id는 없음: DB에서 자동 생성되므로                              │
# │ - name, price만 클라이언트가 전송                               │
# └────────────────────────────────────────────────────────────────┘

@app.post("/items", status_code=201)
# ┌────────────────────────────────────────────────────────────────┐
# │ @app.post: POST 메서드로 요청을 받는 엔드포인트 등록             │
# │ "/items": URL 경로                                             │
# │ status_code=201: 성공 시 201 Created 반환                       │
# │                                                                │
# │ HTTP 상태 코드:                                                 │
# │ - 200 OK: 일반적인 성공                                         │
# │ - 201 Created: 새 리소스 생성 성공                              │
# │ - 204 No Content: 성공했지만 반환할 내용 없음                   │
# │ - 404 Not Found: 리소스를 찾을 수 없음                          │
# └────────────────────────────────────────────────────────────────┘

def create_item_api(body: ItemCreateRequest) -> ItemResponse:
    # ┌────────────────────────────────────────────────────────────┐
    # │ body: ItemCreateRequest                                    │
    # │ - 클라이언트가 보낸 JSON이 자동으로 파싱됨                   │
    # │ - 타입이 맞지 않으면 자동으로 422 에러 반환                  │
    # │                                                            │
    # │ -> ItemResponse                                            │
    # │ - 반환 타입 힌트: 문서화 및 응답 검증에 사용                  │
    # └────────────────────────────────────────────────────────────┘
    
    with SessionFactory() as session:
        # ┌────────────────────────────────────────────────────────┐
        # │ with문으로 세션 생성                                    │
        # │ - 블록이 끝나면 자동으로 세션 종료                       │
        # │ - 예외 발생 시 자동으로 rollback                        │
        # └────────────────────────────────────────────────────────┘
        
        new_item = Item(name=body.name, price=body.price)
        # └── Item 객체 생성 (아직 DB에 저장 안 됨)
        
        session.add(new_item)
        # ┌────────────────────────────────────────────────────────┐
        # │ session.add(): 세션에 객체 등록                         │
        # │ - "이 객체를 DB에 저장할 거야"라고 세션에 알림           │
        # │ - 아직 DB에 저장되지 않음 (pending 상태)                 │
        # └────────────────────────────────────────────────────────┘
        
        session.commit()  # DB에 반영
        # ┌────────────────────────────────────────────────────────┐
        # │ session.commit(): 실제로 DB에 저장                      │
        # │ - pending 상태의 모든 변경사항을 DB에 반영               │
        # │ - INSERT INTO items (name, price) VALUES (...) 실행    │
        # │ - id가 자동으로 할당됨                                  │
        # └────────────────────────────────────────────────────────┘
        
        return new_item
        # ┌────────────────────────────────────────────────────────┐
        # │ Item 객체를 반환                                        │
        # │ - FastAPI가 자동으로 ItemResponse 형태의 JSON으로 변환  │
        # │ - expire_on_commit=False이므로 세션 종료 후에도 사용 가능│
        # └────────────────────────────────────────────────────────┘
```

## 📖 Read (조회) - GET /items

```python
# R: 전체 상품 조회 API
@app.get("/items", status_code=200)
def get_items_api() -> list[ItemResponse]:
    # └── 반환 타입: ItemResponse의 리스트 (여러 개)
    
    with SessionFactory() as session:
        stmt = select(Item)  # statement = SQL 구문
        # ┌────────────────────────────────────────────────────────┐
        # │ select(Item): SELECT 쿼리 생성                          │
        # │ - 실제 SQL: SELECT * FROM items                        │
        # │ - 아직 실행되지 않음 (쿼리 객체만 생성)                  │
        # └────────────────────────────────────────────────────────┘
        
        items = session.scalars(stmt).all()
        # ┌────────────────────────────────────────────────────────┐
        # │ session.scalars(stmt): 쿼리 실행, 결과를 ORM 객체로 반환│
        # │ .all(): 모든 결과를 리스트로 가져옴                      │
        # │                                                        │
        # │ scalars vs execute:                                    │
        # │ - scalars(): Item 객체들의 리스트 반환                  │
        # │ - execute(): Row 객체들의 리스트 반환 (튜플 형태)        │
        # └────────────────────────────────────────────────────────┘
        
        return items
```

## 📖 Read (단일 조회) - GET /items/{item_id}

```python
# R: 단일 상품 조회 API
@app.get("/items/{item_id}", status_code=200)
# ┌────────────────────────────────────────────────────────────────┐
# │ {item_id}: 경로 매개변수 (Path Parameter)                       │
# │ - URL에서 값을 추출                                            │
# │ - 예: GET /items/1 → item_id = 1                               │
# └────────────────────────────────────────────────────────────────┘

def get_item_api(item_id: int) -> ItemResponse:
    # └── item_id: int → 자동으로 정수로 변환 (문자열이면 422 에러)
    
    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
        # ┌────────────────────────────────────────────────────────┐
        # │ .where(조건): WHERE 절 추가                             │
        # │ - Item.id == item_id: id가 일치하는 행만 선택           │
        # │ - 실제 SQL: SELECT * FROM items WHERE id = ?           │
        # └────────────────────────────────────────────────────────┘
        
        item: Item | None = session.scalar(stmt)
        # ┌────────────────────────────────────────────────────────┐
        # │ session.scalar(): 단일 결과 반환 (0개 또는 1개)         │
        # │ - 결과가 있으면: Item 객체 반환                         │
        # │ - 결과가 없으면: None 반환                              │
        # │                                                        │
        # │ scalar vs scalars:                                     │
        # │ - scalar(): 단일 결과 (없으면 None)                     │
        # │ - scalars(): 여러 결과 (반복 가능한 객체)               │
        # └────────────────────────────────────────────────────────┘
        
        if item is None:
            raise HTTPException(
                status_code=404, detail=f"Item Not Found(id: {item_id})",
            )
        # ┌────────────────────────────────────────────────────────┐
        # │ HTTPException: HTTP 오류 응답 발생                       │
        # │ - status_code=404: Not Found                           │
        # │ - detail: 클라이언트에게 보여줄 에러 메시지              │
        # │                                                        │
        # │ 클라이언트가 받는 응답:                                  │
        # │ {                                                      │
        # │   "detail": "Item Not Found(id: 999)"                  │
        # │ }                                                      │
        # └────────────────────────────────────────────────────────┘
        
        return item
```

## ✏️ Update (부분 수정) - PATCH /items/{item_id}

```python
# U: 상품 수정 API
class ItemUpdateRequest(BaseModel):
    name: str | None = None
    price: int | None = None
# ┌────────────────────────────────────────────────────────────────┐
# │ PATCH용 요청 스키마                                             │
# │                                                                │
# │ str | None = None:                                             │
# │ - 이 필드는 선택사항 (보내지 않아도 됨)                         │
# │ - 보내지 않으면 None                                           │
# │ - 보낸 필드만 수정됨 (부분 업데이트)                            │
# │                                                                │
# │ PATCH vs PUT:                                                  │
# │ - PATCH: 일부 필드만 수정 (나머지는 유지)                       │
# │ - PUT: 전체 리소스를 대체 (모든 필드 필수)                      │
# └────────────────────────────────────────────────────────────────┘

@app.patch("/items/{item_id}", status_code=200)
def update_item_api(item_id: int, body: ItemUpdateRequest) -> ItemResponse:
    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
        item: Item | None = session.scalar(stmt)
        
        if item is None:
            raise HTTPException(
                status_code=404, detail=f"Item Not Found(id: {item_id})",
            )
        
        # 객체의 값을 변경하고 commit()하면, 그대로 데이터가 DB에 반영됨
        if body.name is not None:
            item.name = body.name
        if body.price is not None:
            item.price = body.price
        # ┌────────────────────────────────────────────────────────┐
        # │ is not None 체크가 중요한 이유:                         │
        # │                                                        │
        # │ 잘못된 방식: if body.price:                             │
        # │ - price=0 이면 False → 0원으로 수정 불가!               │
        # │ - price="" 이면 False → 빈 문자열로 수정 불가!          │
        # │                                                        │
        # │ 올바른 방식: if body.price is not None:                 │
        # │ - None이 아닌 모든 값(0, "", False 포함) 허용           │
        # └────────────────────────────────────────────────────────┘
        
        session.commit()  # session에 등록된 데이터를 DB로 저장
        # ┌────────────────────────────────────────────────────────┐
        # │ ORM의 변경 감지 (Dirty Tracking)                        │
        # │                                                        │
        # │ item.name = "새이름" 만 해도 SQLAlchemy가 자동 감지      │
        # │ → commit() 시 UPDATE items SET name='새이름' WHERE id=? │
        # │ → session.add() 불필요! (이미 세션에 연결되어 있음)      │
        # └────────────────────────────────────────────────────────┘
        
        return item

# ┌────────────────────────────────────────────────────────────────┐
# │ 💡 session.add()가 필요 없는 이유                               │
# │                                                                │
# │ session.add([data])는 "세션에 data를 담아두는 작업"              │
# │                                                                │
# │ 1. 새 객체 생성 시: session.add(new_item) 필요                 │
# │    → new_item은 세션과 연결되어 있지 않음                       │
# │                                                                │
# │ 2. 기존 객체 수정 시: session.add() 불필요                      │
# │    → session.scalar()로 가져온 객체는 이미 세션에 연결됨        │
# │    → 속성만 변경하고 commit()하면 자동 반영                     │
# └────────────────────────────────────────────────────────────────┘
```

## ✏️ Update (전체 교체) - PUT /items/{item_id}

```python
# U: 상품 수정 API
class ItemReplaceUpdate(BaseModel):
    name: str
    price: int
# ┌────────────────────────────────────────────────────────────────┐
# │ PUT용 요청 스키마                                               │
# │ - 모든 필드가 필수 (None 허용 안 함)                            │
# │ - 리소스 전체를 새 값으로 교체                                  │
# └────────────────────────────────────────────────────────────────┘

@app.put("/items/{item_id}", status_code=200)
def replace_item_api(item_id: int, body: ItemReplaceUpdate) -> ItemResponse:
    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
        item: Item | None = session.scalar(stmt)
        
        if item is None:
            raise HTTPException(
                status_code=404, detail=f"Item Not Found(id: {item_id})",
            )
        
        item.name = body.name
        item.price = body.price
        # └── 모든 필드를 새 값으로 교체 (조건 체크 없음)
        
        session.commit()
        return item
```

## 🗑️ Delete (삭제) - DELETE /items/{item_id}

```python
# D: 상품 삭제 API
@app.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
# ┌────────────────────────────────────────────────────────────────┐
# │ status.HTTP_204_NO_CONTENT = 204                               │
# │                                                                │
# │ 204 No Content:                                                │
# │ - "성공했지만 반환할 내용이 없다"                               │
# │ - 삭제 작업에 적합                                             │
# │ - 응답 본문(body)이 비어있음                                    │
# └────────────────────────────────────────────────────────────────┘

def delete_item_api(item_id: int) -> None:
    # └── 반환 타입 None: 아무것도 반환하지 않음
    
    with SessionFactory() as session:
        stmt = select(Item).where(Item.id == item_id)
        item: Item | None = session.scalar(stmt)
        
        if item is None:
            raise HTTPException(
                status_code=404, detail=f"Item Not Found(id: {item_id})",
            )
        
        session.delete(item)
        # ┌────────────────────────────────────────────────────────┐
        # │ session.delete(item): 세션에서 객체 삭제 표시           │
        # │ - 아직 DB에서 삭제되지 않음                             │
        # │ - commit() 시 DELETE FROM items WHERE id = ? 실행      │
        # └────────────────────────────────────────────────────────┘
        
        session.commit()
        # return할 필요없는 이유 : delete는 반환값이 없다. -> 204
```

---

# 5️⃣ 과제115.py - 비동기 프로그래밍 과제

> **역할**: asyncio를 사용한 비동기 실행 순서 제어 연습

## 🎯 과제 목표

```
출력 순서:
C 시작 → A 시작 → A 끝 → B 시작 → C 끝 → B 끝
```

## 📝 정답 코드

```python
import asyncio
# ┌────────────────────────────────────────────────────────────────┐
# │ asyncio: 파이썬 비동기 프로그래밍 표준 라이브러리               │
# │ - async/await 문법 지원                                        │
# │ - 동시에 여러 작업을 효율적으로 처리                            │
# └────────────────────────────────────────────────────────────────┘

async def a():
    await asyncio.sleep(1)   # t=0~1: 1초 대기
    print("A 시작")          # t=1: 출력
    await asyncio.sleep(2)   # t=1~3: 2초 대기
    print("A 끝")            # t=3: 출력

async def b():
    await asyncio.sleep(4)   # t=0~4: 4초 대기
    print("B 시작")          # t=4: 출력
    await asyncio.sleep(6)   # t=4~10: 6초 대기
    print("B 끝")            # t=10: 출력

async def c():
    await asyncio.sleep(0)   # t=0: 즉시 (대기 안 함)
    print("C 시작")          # t=0: 출력
    await asyncio.sleep(5)   # t=0~5: 5초 대기
    print("C 끝")            # t=5: 출력

async def main():
    await asyncio.gather(a(), b(), c())
    # ┌────────────────────────────────────────────────────────────┐
    # │ asyncio.gather(): 여러 코루틴을 동시에 실행                 │
    # │ - a(), b(), c()가 동시에 시작됨                             │
    # │ - 각각 독립적으로 실행되며, 모두 끝날 때까지 대기            │
    # └────────────────────────────────────────────────────────────┘

asyncio.run(main())
# ┌────────────────────────────────────────────────────────────────┐
# │ asyncio.run(): 비동기 프로그램의 진입점                         │
# │ - 이벤트 루프 생성 및 실행                                      │
# │ - main() 코루틴이 완료될 때까지 실행                            │
# └────────────────────────────────────────────────────────────────┘
```

## ⏱️ 타임라인 분석

```
시간(초)   a()          b()          c()          출력
──────────────────────────────────────────────────────────────────
t=0     sleep(1)↓    sleep(4)↓    sleep(0)→    "C 시작"
t=1     "A 시작"→     ↓            sleep(5)↓
t=2     sleep(2)↓     ↓              ↓
t=3     "A 끝"→       ↓              ↓
t=4       끝        "B 시작"→        ↓
t=5                  sleep(6)↓    "C 끝"→
t=10                 "B 끝"→        끝           끝
──────────────────────────────────────────────────────────────────
                                         총 실행시간: 10초
```

## 🔑 핵심 개념

```python
# ┌────────────────────────────────────────────────────────────────┐
# │ 💡 비동기의 핵심: "기다리는 동안 다른 일 하기"                  │
# │                                                                │
# │ 동기 방식 (순차 실행):                                          │
# │   a() 실행 → 완료 → b() 실행 → 완료 → c() 실행 → 완료          │
# │   총 시간: 3 + 10 + 5 = 18초                                   │
# │                                                                │
# │ 비동기 방식 (동시 실행):                                        │
# │   a(), b(), c() 동시 시작                                      │
# │   sleep() 중에는 다른 함수가 실행됨                             │
# │   총 시간: 가장 긴 함수의 시간 = 10초                           │
# └────────────────────────────────────────────────────────────────┘
```

---

# 6️⃣ practice.py - 비동기 연습

> **역할**: 간단한 비동기 실행 순서 연습

```python
import asyncio

async def a():
    await asyncio.sleep(1)   # 1초 대기
    print("A 시작")
    await asyncio.sleep(1)   # 1초 대기
    print("A 끝")

async def b():
    await asyncio.sleep(3)   # 3초 대기
    print("B 시작")
    await asyncio.sleep(2)   # 2초 대기
    print("B 끝")

async def c():
    await asyncio.sleep(0)   # 즉시
    print("C 시작")
    await asyncio.sleep(4)   # 4초 대기
    print("C 끝")

async def main():
    await asyncio.gather(a(), b(), c())

asyncio.run(main())
```

### 실행 결과

```
C 시작    (t=0)
A 시작    (t=1)
A 끝      (t=2)
B 시작    (t=3)
C 끝      (t=4)
B 끝      (t=5)
```

---

# 7️⃣ sync.py - 동기 vs 비동기 비교

> **역할**: 동기와 비동기 방식의 성능 차이 비교

## 동기 방식 (주석 처리됨)

```python
import time

def a():
    print("A 시작")
    time.sleep(2)    # 2초 동안 멈춤 (블로킹)
    print("A 종료")

def b():
    print("B 시작")
    time.sleep(2)    # 2초 동안 멈춤 (블로킹)
    print("B 종료")

start = time.time()
a()  # a() 완료될 때까지 대기
b()  # b() 완료될 때까지 대기
end = time.time()
print(f"{end - start:.3f}초")  # 약 4.000초
# ┌────────────────────────────────────────────────────────────────┐
# │ 동기 방식의 문제:                                               │
# │ - a()가 time.sleep(2)로 기다리는 동안 아무것도 못 함            │
# │ - b()도 마찬가지                                                │
# │ - 총 시간: 2 + 2 = 4초                                         │
# └────────────────────────────────────────────────────────────────┘
```

## 비동기 방식

```python
import asyncio
import time

async def a():
    print("A 시작")
    await asyncio.sleep(2)  # 2초 대기 (non-blocking)
    print("A 종료")

async def b():
    print("B 시작")
    await asyncio.sleep(2)  # 2초 대기 (non-blocking)
    print("B 종료")

async def main():
    start = time.time()
    await asyncio.gather(a(), b())  # 동시에 실행
    end = time.time()
    print(f"{end - start:.3f}초")  # 약 2.000초

asyncio.run(main())
# ┌────────────────────────────────────────────────────────────────┐
# │ 비동기 방식의 장점:                                             │
# │ - a()가 await asyncio.sleep(2)로 기다리는 동안 b() 실행         │
# │ - 두 함수가 "동시에" 대기                                       │
# │ - 총 시간: max(2, 2) = 2초                                     │
# │                                                                │
# │ 시간 절약: 4초 → 2초 (50% 단축!)                                │
# └────────────────────────────────────────────────────────────────┘
```

---

## 📊 핵심 용어 정리

| 용어 | 설명 |
|------|------|
| **ORM** | Object-Relational Mapping, 객체와 DB 테이블을 매핑 |
| **Session** | DB와의 대화 단위, 트랜잭션 관리 |
| **Engine** | DB 연결 풀 관리, SQL 실행 담당 |
| **commit()** | 변경사항을 실제 DB에 반영 |
| **rollback()** | 변경사항 취소 |
| **async/await** | 비동기 함수 정의 및 호출 문법 |
| **asyncio.gather()** | 여러 코루틴을 동시에 실행 |
| **CRUD** | Create, Read, Update, Delete의 약자 |

---

## 🚀 실행 방법

```bash
# CRUD API 서버 실행
cd /Users/admin/Desktop/FASTAPI/1.15
fastapi dev crud_session.py

# 비동기 과제 실행
python 과제115.py

# 동기/비동기 비교 실행
python sync.py
```

